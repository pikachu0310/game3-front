/* tslint:disable */
/* eslint-disable */
/**
 * Game^3 API
 * Game^3 API
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Game,
} from '../models/index';
import {
    GameFromJSON,
    GameToJSON,
} from '../models/index';

export interface GetEventGamesRequest {
    eventId: string;
}

export interface GetGameRequest {
    gameId: string;
}

export interface GetGameImageRequest {
    gameId: string;
}

export interface PatchGameRequest {
    gameId: string;
    creatorName: string;
    title: string;
    organization?: string;
    twitterId?: string;
    websiteUrl?: string;
    genre?: string;
    developmentEnvironment?: string;
    description?: string;
    image?: Blob;
}

export interface PostGameRequest {
    creatorName: string;
    title: string;
    organization?: string;
    twitterId?: string;
    websiteUrl?: string;
    genre?: string;
    developmentEnvironment?: string;
    description?: string;
    image?: Blob;
}

/**
 * 
 */
export class GamesApi extends runtime.BaseAPI {

    /**
     * イベントに登録されているゲームのリストを取得
     */
    async getEventGamesRaw(requestParameters: GetEventGamesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Game>>> {
        if (requestParameters.eventId === null || requestParameters.eventId === undefined) {
            throw new runtime.RequiredError('eventId','Required parameter requestParameters.eventId was null or undefined when calling getEventGames.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/events/{eventId}/games`.replace(`{${"eventId"}}`, encodeURIComponent(String(requestParameters.eventId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GameFromJSON));
    }

    /**
     * イベントに登録されているゲームのリストを取得
     */
    async getEventGames(requestParameters: GetEventGamesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Game>> {
        const response = await this.getEventGamesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * ゲーム情報を取得
     */
    async getGameRaw(requestParameters: GetGameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Game>> {
        if (requestParameters.gameId === null || requestParameters.gameId === undefined) {
            throw new runtime.RequiredError('gameId','Required parameter requestParameters.gameId was null or undefined when calling getGame.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/games/{gameId}`.replace(`{${"gameId"}}`, encodeURIComponent(String(requestParameters.gameId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GameFromJSON(jsonValue));
    }

    /**
     * ゲーム情報を取得
     */
    async getGame(requestParameters: GetGameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Game> {
        const response = await this.getGameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * ゲームの画像を取得
     */
    async getGameImageRaw(requestParameters: GetGameImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.gameId === null || requestParameters.gameId === undefined) {
            throw new runtime.RequiredError('gameId','Required parameter requestParameters.gameId was null or undefined when calling getGameImage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/games/{gameId}/image`.replace(`{${"gameId"}}`, encodeURIComponent(String(requestParameters.gameId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * ゲームの画像を取得
     */
    async getGameImage(requestParameters: GetGameImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getGameImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * ゲーム情報を変更
     */
    async patchGameRaw(requestParameters: PatchGameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.gameId === null || requestParameters.gameId === undefined) {
            throw new runtime.RequiredError('gameId','Required parameter requestParameters.gameId was null or undefined when calling patchGame.');
        }

        if (requestParameters.creatorName === null || requestParameters.creatorName === undefined) {
            throw new runtime.RequiredError('creatorName','Required parameter requestParameters.creatorName was null or undefined when calling patchGame.');
        }

        if (requestParameters.title === null || requestParameters.title === undefined) {
            throw new runtime.RequiredError('title','Required parameter requestParameters.title was null or undefined when calling patchGame.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.creatorName !== undefined) {
            formParams.append('creatorName', requestParameters.creatorName as any);
        }

        if (requestParameters.organization !== undefined) {
            formParams.append('organization', requestParameters.organization as any);
        }

        if (requestParameters.twitterId !== undefined) {
            formParams.append('twitterId', requestParameters.twitterId as any);
        }

        if (requestParameters.websiteUrl !== undefined) {
            formParams.append('websiteUrl', requestParameters.websiteUrl as any);
        }

        if (requestParameters.title !== undefined) {
            formParams.append('title', requestParameters.title as any);
        }

        if (requestParameters.genre !== undefined) {
            formParams.append('genre', requestParameters.genre as any);
        }

        if (requestParameters.developmentEnvironment !== undefined) {
            formParams.append('developmentEnvironment', requestParameters.developmentEnvironment as any);
        }

        if (requestParameters.description !== undefined) {
            formParams.append('description', requestParameters.description as any);
        }

        if (requestParameters.image !== undefined) {
            formParams.append('image', requestParameters.image as any);
        }

        const response = await this.request({
            path: `/games/{gameId}`.replace(`{${"gameId"}}`, encodeURIComponent(String(requestParameters.gameId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * ゲーム情報を変更
     */
    async patchGame(requestParameters: PatchGameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchGameRaw(requestParameters, initOverrides);
    }

    /**
     * ゲームを登録
     */
    async postGameRaw(requestParameters: PostGameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Game>> {
        if (requestParameters.creatorName === null || requestParameters.creatorName === undefined) {
            throw new runtime.RequiredError('creatorName','Required parameter requestParameters.creatorName was null or undefined when calling postGame.');
        }

        if (requestParameters.title === null || requestParameters.title === undefined) {
            throw new runtime.RequiredError('title','Required parameter requestParameters.title was null or undefined when calling postGame.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.creatorName !== undefined) {
            formParams.append('creatorName', requestParameters.creatorName as any);
        }

        if (requestParameters.organization !== undefined) {
            formParams.append('organization', requestParameters.organization as any);
        }

        if (requestParameters.twitterId !== undefined) {
            formParams.append('twitterId', requestParameters.twitterId as any);
        }

        if (requestParameters.websiteUrl !== undefined) {
            formParams.append('websiteUrl', requestParameters.websiteUrl as any);
        }

        if (requestParameters.title !== undefined) {
            formParams.append('title', requestParameters.title as any);
        }

        if (requestParameters.genre !== undefined) {
            formParams.append('genre', requestParameters.genre as any);
        }

        if (requestParameters.developmentEnvironment !== undefined) {
            formParams.append('developmentEnvironment', requestParameters.developmentEnvironment as any);
        }

        if (requestParameters.description !== undefined) {
            formParams.append('description', requestParameters.description as any);
        }

        if (requestParameters.image !== undefined) {
            formParams.append('image', requestParameters.image as any);
        }

        const response = await this.request({
            path: `/games`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GameFromJSON(jsonValue));
    }

    /**
     * ゲームを登録
     */
    async postGame(requestParameters: PostGameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Game> {
        const response = await this.postGameRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
